<!doctype html>
<html
  {% if request.design_mode %}
    class="shopify-design-mode"
  {% endif %}
  lang="{{ request.locale.iso_code }}"
>
  <head>
    {%- if settings.favicon != blank -%}
      <link rel="icon" type="image/png" href="{{ settings.favicon | image_url: width: 32, height: 32 }}">
    {%- endif -%}

    {%- comment -%} Preconnect to external resources for faster loading {%- endcomment -%}
    <link rel="preconnect" href="https://cdn.shopify.com" crossorigin>
    <link rel="dns-prefetch" href="https://cdn.shopify.com">

    {% comment %} This a way to wait for main content to load when navigating to a new page so that the view transitions can work consistently {% endcomment %}
    {% if settings.transition_to_main_product or settings.page_transition_enabled %}
      <link
        rel="expect"
        href="#MainContent"
        blocking="render"
        id="view-transition-render-blocker"
      >
    {% endif %}

    {%- render 'meta-tags' -%}
    {%- render 'stylesheets' -%}
    {%- render 'fonts' -%}
    {%- render 'scripts' -%}
    {%- render 'theme-styles-variables' -%}
    {%- render 'color-schemes' -%}

    {% if request.design_mode %}
      {%- render 'theme-editor' -%}
    {% endif %}

    {{ content_for_header }}

    {%- comment -%} Organization Schema for Knowledge Graph {%- endcomment -%}
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Organization",
        "name": "{{ shop.name }}",
        "url": "{{ shop.url }}",
        {%- if settings.logo -%}
        "logo": "{{ settings.logo | image_url: width: 500 }}",
        {%- endif -%}
        "description": "{{ shop.description | escape }}",
        "address": {
          "@type": "PostalAddress",
          "addressCountry": "SE"
        },
        "sameAs": [
          {%- if settings.social_instagram_link != blank -%}"{{ settings.social_instagram_link }}"{%- endif -%}
          {%- if settings.social_facebook_link != blank -%}{%- if settings.social_instagram_link != blank -%},{%- endif -%}"{{ settings.social_facebook_link }}"{%- endif -%}
          {%- if settings.social_twitter_link != blank -%}{%- if settings.social_facebook_link != blank or settings.social_instagram_link != blank -%},{%- endif -%}"{{ settings.social_twitter_link }}"{%- endif -%}
        ]
      }
    </script>
  </head>

  <body class="page-width-{{ settings.page_width }} card-hover-effect-{{ settings.card_hover_effect }}">
    {% render 'skip-to-content-link', href: '#MainContent', text: 'accessibility.skip_to_text' %}
    <div id="header-group">
      {% sections 'header-group' %}
    </div>

    <script>
      // Inline header height calculation to prevent layout shift
      // Note: Updates in calculateHeaderGroupHeight() and updateTransparentHeaderOffset()utilities.js should be kept in sync with this function
      (function setHeaderHeighCustomProperties() {
        /*
         * Header calculation functions for maintaining CSS variables
         * Mimic calculateHeaderGroupHeight() in utilities.js
         */
        const header = document.querySelector('header-component');
        const headerGroup = document.querySelector('#header-group');
        const hasHeaderSection = headerGroup?.querySelector('.header-section');

        if (!header || !headerGroup) return;

        const headerHeight = header.offsetHeight;

        // Calculate the total height of the header group
        let headerGroupHeight = 0;
        const children = headerGroup.children;
        for (let i = 0; i < children.length; i++) {
          const element = children[i];
          if (element === header || !(element instanceof HTMLElement)) continue;
          headerGroupHeight += element.offsetHeight;
        }

        // Check for transparent header special case
        if (header.hasAttribute('transparent') && header.parentElement?.nextElementSibling) {
          headerGroupHeight += headerHeight;
        }

        // Set CSS variables
        document.body.style.setProperty('--header-height', `${headerHeight}px`);
        document.body.style.setProperty('--header-group-height', `${headerGroupHeight}px`);

        /**
         * Updates CSS custom properties for transparent header offset calculation
         * Mimic updateTransparentHeaderOffset() in utilities.js
         */

        if (!hasHeaderSection || !header?.hasAttribute('transparent')) {
          document.body.style.setProperty('--transparent-header-offset-boolean', '0');
          return;
        }

        const hasImmediateSection = hasHeaderSection.nextElementSibling?.classList.contains('shopify-section');

        const shouldApplyOffset = !hasImmediateSection ? '1' : '0';
        document.body.style.setProperty('--transparent-header-offset-boolean', shouldApplyOffset);
      })();
    </script>

    <main
      id="MainContent"
      class="content-for-layout"
      role="main"
      data-page-transition-enabled="{{ settings.page_transition_enabled }}"
      data-product-transition="{{ settings.transition_to_main_product }}"
      data-template="{{ template }}"
    >
      {{ content_for_layout }}
    </main>

    {% sections 'footer-group' %}

    {% render 'search-modal' %}

    {% if settings.quick_add or settings.mobile_quick_add %}
      {% render 'quick-add-modal' %}
    {% endif %}

    {% section 'moby-cart-drawer' %}
    {% render 'moby-sticky-cart' %}
    {% render 'moby-animations' %}

    {%- comment -%} Global Cart Interceptor - Prevents redirects, opens drawer instead {%- endcomment -%}
    {%- comment -%} Includes stock validation to prevent overselling {%- endcomment -%}
    <script>
    (function() {
      // Intercept ALL form submissions to /cart/add
      document.addEventListener('submit', async function(e) {
        const form = e.target;
        if (!form || form.action.indexOf('/cart/add') === -1) return;

        e.preventDefault();

        const submitBtn = form.querySelector('button[type="submit"], input[type="submit"]');
        const originalContent = submitBtn ? submitBtn.innerHTML : '';

        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.innerHTML = '<span>Adding...</span>';
        }

        try {
          const formData = new FormData(form);
          const data = {};

          // Convert FormData to object
          for (let [key, value] of formData.entries()) {
            if (key === 'id' || key === 'quantity' || key === 'selling_plan') {
              data[key] = value;
            }
          }

          // Ensure quantity is a number
          if (data.quantity) data.quantity = parseInt(data.quantity) || 1;

          // Check stock if inventory data is available on the form
          const inventoryQty = form.dataset.inventoryQuantity ? parseInt(form.dataset.inventoryQuantity) : null;
          const inventoryPolicy = form.dataset.inventoryPolicy || 'deny';
          const productId = form.dataset.productId;

          if (inventoryQty !== null && inventoryPolicy === 'deny') {
            // Fetch current cart to check existing quantity
            const cartResponse = await fetch('/cart.js', {
              headers: { 'Accept': 'application/json' }
            });
            const cart = await cartResponse.json();

            // Count how many of this variant/product are already in cart
            let currentQtyInCart = 0;
            cart.items.forEach(item => {
              if (String(item.variant_id) === String(data.id) ||
                  (productId && String(item.product_id) === String(productId))) {
                currentQtyInCart += item.quantity;
              }
            });

            const totalAfterAdd = currentQtyInCart + data.quantity;

            if (totalAfterAdd > inventoryQty) {
              const remaining = inventoryQty - currentQtyInCart;
              if (remaining <= 0) {
                throw new Error('No more stock available');
              } else {
                throw new Error(`Only ${remaining} more available`);
              }
            }
          }

          const response = await fetch('/cart/add.js', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify(data)
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.description || errorData.message || 'Failed to add to cart');
          }

          // Success
          if (submitBtn) submitBtn.innerHTML = '<span>Added!</span>';

          // Open cart drawer
          setTimeout(() => {
            if (typeof window.openCartDrawer === 'function') {
              window.openCartDrawer();
            }
            if (submitBtn) {
              submitBtn.innerHTML = originalContent;
              submitBtn.disabled = false;
            }
          }, 300);

        } catch (error) {
          console.error('Add to cart error:', error);
          if (submitBtn) {
            const errorText = error.message && error.message.length < 50 ? error.message : 'Error';
            submitBtn.innerHTML = `<span>${errorText}</span>`;
            setTimeout(() => {
              submitBtn.innerHTML = originalContent;
              submitBtn.disabled = false;
            }, 2000);
          }
        }
      });
    })();
    </script>
  </body>
</html>
