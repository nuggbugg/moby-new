<!doctype html>
<html
  {% if request.design_mode %}
    class="shopify-design-mode"
  {% endif %}
  lang="{{ request.locale.iso_code }}"
>
  <head>
    {%- if settings.favicon != blank -%}
      <link rel="icon" type="image/png" href="{{ settings.favicon | image_url: width: 32, height: 32 }}">
    {%- endif -%}

    {%- comment -%} Google Search Console Verification {%- endcomment -%}
    <meta name="google-site-verification" content="VLPiTXngI_UjNxP3uvxug3lFy2LKsq7MOxyXNdoVG7A" />

    {%- comment -%} Preconnect to external resources for faster loading {%- endcomment -%}
    <link rel="preconnect" href="https://cdn.shopify.com" crossorigin>
    <link rel="dns-prefetch" href="https://cdn.shopify.com">
    {%- comment -%} Preconnect to third-party analytics/marketing domains {%- endcomment -%}
    <link rel="preconnect" href="https://www.googletagmanager.com" crossorigin>
    <link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
    <link rel="preconnect" href="https://connect.facebook.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="dns-prefetch" href="https://www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://connect.facebook.net">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">

    {% comment %} This a way to wait for main content to load when navigating to a new page so that the view transitions can work consistently {% endcomment %}
    {% if settings.transition_to_main_product or settings.page_transition_enabled %}
      <link
        rel="expect"
        href="#MainContent"
        blocking="render"
        id="view-transition-render-blocker"
      >
    {% endif %}

    {%- render 'meta-tags' -%}
    {%- render 'stylesheets' -%}
    {%- render 'fonts' -%}
    {%- render 'scripts' -%}
    {%- render 'theme-styles-variables' -%}
    {%- render 'color-schemes' -%}

    {% if request.design_mode %}
      {%- render 'theme-editor' -%}
    {% endif %}

    {{ content_for_header }}

    {%- comment -%} Organization Schema for Knowledge Graph {%- endcomment -%}
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Organization",
        "name": "{{ shop.name }}",
        "url": "{{ shop.url }}",
        {%- if settings.logo -%}
        "logo": "{{ settings.logo | image_url: width: 500 }}",
        {%- endif -%}
        "description": "{{ shop.description | escape }}",
        "address": {
          "@type": "PostalAddress",
          "addressCountry": "SE"
        },
        "sameAs": [
          {%- if settings.social_instagram_link != blank -%}"{{ settings.social_instagram_link }}"{%- endif -%}
          {%- if settings.social_facebook_link != blank -%}{%- if settings.social_instagram_link != blank -%},{%- endif -%}"{{ settings.social_facebook_link }}"{%- endif -%}
          {%- if settings.social_twitter_link != blank -%}{%- if settings.social_facebook_link != blank or settings.social_instagram_link != blank -%},{%- endif -%}"{{ settings.social_twitter_link }}"{%- endif -%}
        ]
      }
    </script>
    
  </head>

  <body class="page-width-{{ settings.page_width }} card-hover-effect-{{ settings.card_hover_effect }}">
    {% render 'skip-to-content-link', href: '#MainContent', text: 'accessibility.skip_to_text' %}
    <div id="header-group">
      {% sections 'header-group' %}
    </div>

    <script>
      // Inline header height calculation to prevent layout shift
      // Note: Updates in calculateHeaderGroupHeight() and updateTransparentHeaderOffset()utilities.js should be kept in sync with this function
      (function setHeaderHeighCustomProperties() {
        /*
         * Header calculation functions for maintaining CSS variables
         * Mimic calculateHeaderGroupHeight() in utilities.js
         */
        const header = document.querySelector('header-component');
        const headerGroup = document.querySelector('#header-group');
        const hasHeaderSection = headerGroup?.querySelector('.header-section');

        if (!header || !headerGroup) return;

        const headerHeight = header.offsetHeight;

        // Calculate the total height of the header group
        let headerGroupHeight = 0;
        const children = headerGroup.children;
        for (let i = 0; i < children.length; i++) {
          const element = children[i];
          if (element === header || !(element instanceof HTMLElement)) continue;
          headerGroupHeight += element.offsetHeight;
        }

        // Check for transparent header special case
        if (header.hasAttribute('transparent') && header.parentElement?.nextElementSibling) {
          headerGroupHeight += headerHeight;
        }

        // Set CSS variables
        document.body.style.setProperty('--header-height', `${headerHeight}px`);
        document.body.style.setProperty('--header-group-height', `${headerGroupHeight}px`);

        /**
         * Updates CSS custom properties for transparent header offset calculation
         * Mimic updateTransparentHeaderOffset() in utilities.js
         */

        if (!hasHeaderSection || !header?.hasAttribute('transparent')) {
          document.body.style.setProperty('--transparent-header-offset-boolean', '0');
          return;
        }

        const hasImmediateSection = hasHeaderSection.nextElementSibling?.classList.contains('shopify-section');

        const shouldApplyOffset = !hasImmediateSection ? '1' : '0';
        document.body.style.setProperty('--transparent-header-offset-boolean', shouldApplyOffset);
      })();
    </script>

    <main
      id="MainContent"
      class="content-for-layout"
      role="main"
      data-page-transition-enabled="{{ settings.page_transition_enabled }}"
      data-product-transition="{{ settings.transition_to_main_product }}"
      data-template="{{ template }}"
    >
      {{ content_for_layout }}
    </main>

    {% sections 'footer-group' %}

    {% render 'search-modal' %}

    {% if settings.quick_add or settings.mobile_quick_add %}
      {% render 'quick-add-modal' %}
    {% endif %}

    {% section 'moby-cart-drawer' %}
    {% section 'moby-newsletter-popup' %}
    {% render 'moby-animations' %}

    {%- comment -%} Global Cart Interceptor - Prevents redirects, opens drawer instead {%- endcomment -%}
    {%- comment -%} Includes real-time stock validation to prevent overselling {%- endcomment -%}
    <script>
    (function() {
      // Intercept ALL form submissions to /cart/add
      document.addEventListener('submit', async function(e) {
        const form = e.target;
        if (!form || form.action.indexOf('/cart/add') === -1) return;

        // Skip if form has custom handler flag (buy-box handles its own submission)
        if (form.dataset.customHandler === 'true') return;

        e.preventDefault();

        const submitBtn = form.querySelector('button[type="submit"], input[type="submit"]');
        const originalContent = submitBtn ? submitBtn.innerHTML : '';

        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.innerHTML = '<span>Adding...</span>';
        }

        try {
          const formData = new FormData(form);
          const data = {};

          // Convert FormData to object
          for (let [key, value] of formData.entries()) {
            if (key === 'id' || key === 'quantity' || key === 'selling_plan') {
              data[key] = value;
            }
          }

          // Ensure quantity is a number
          if (!data.quantity) data.quantity = 1;
          data.quantity = parseInt(data.quantity) || 1;

          // Get variant ID
          const variantId = data.id;

          // Fetch cart to find product info and validate stock
          const cartResponse = await fetch('/cart.js', { headers: { 'Accept': 'application/json' } });
          const cart = await cartResponse.json();

          // Try to get product handle from form data attributes or existing cart items
          let productHandle = form.dataset.productHandle;
          let productId = form.dataset.productId;

          // If we don't have product info, try to find it from current cart or page context
          if (!productHandle) {
            // Check if there's a product on the page
            const productMeta = document.querySelector('meta[property="og:url"]');
            if (productMeta) {
              const url = productMeta.content;
              const match = url.match(/\/products\/([^\/\?]+)/);
              if (match) productHandle = match[1];
            }
          }

          // Perform real-time stock validation if we can identify the product
          if (productHandle) {
            const productResponse = await fetch(`/products/${productHandle}.js`, { headers: { 'Accept': 'application/json' } });
            if (productResponse.ok) {
              const productData = await productResponse.json();
              productId = productData.id;

              const variant = productData.variants.find(v => String(v.id) === String(variantId));

              if (variant && variant.inventory_management === 'shopify' && variant.inventory_policy === 'deny') {
                const inventoryQty = variant.inventory_quantity || 0;

                // Count ALL items of this product in cart
                let currentQtyInCart = 0;
                cart.items.forEach(item => {
                  if (String(item.product_id) === String(productId)) {
                    currentQtyInCart += item.quantity;
                  }
                });

                const totalAfterAdd = currentQtyInCart + data.quantity;

                if (totalAfterAdd > inventoryQty) {
                  const remaining = inventoryQty - currentQtyInCart;
                  if (remaining <= 0) {
                    throw new Error('No more stock available');
                  } else {
                    throw new Error(`Only ${remaining} more available`);
                  }
                }
              }
            }
          }

          const response = await fetch('/cart/add.js', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify(data)
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.description || errorData.message || 'Failed to add to cart');
          }

          // Success
          if (submitBtn) submitBtn.innerHTML = '<span>Added!</span>';

          // Open cart drawer
          setTimeout(() => {
            if (typeof window.openCartDrawer === 'function') {
              window.openCartDrawer();
            }
            if (submitBtn) {
              submitBtn.innerHTML = originalContent;
              submitBtn.disabled = false;
            }
          }, 300);

        } catch (error) {
          console.error('Add to cart error:', error);
          if (submitBtn) {
            const errorText = error.message && error.message.length < 50 ? error.message : 'Error';
            submitBtn.innerHTML = `<span>${errorText}</span>`;
            setTimeout(() => {
              submitBtn.innerHTML = originalContent;
              submitBtn.disabled = false;
            }, 2000);
          }
        }
      });
    })();
    </script>
  </body>
</html>
